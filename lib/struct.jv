import builtin

class Map {
  field table, keys
  new(field sz=31) {
    table = []
    table[sz] = None
    keys = []
  }
  method _hash(k) {
    hval = builtin.hash(k)
    pos = hval % sz
    if pos < 0 pos = -pos
    return pos
  }
  ; Associates the key k with the value v in the map.
  method []=(k, v) {
    pos = _hash(k)
    entries = table[pos]
    if ~entries {
      table[pos] = [(k,v)]
      keys.append(k)
      return None
    }
    for i=0, i<entries.len(), i=i+1 {
      if k == entries[i][0] {
        old_v = entries[i][1]
        entries[i] = (k,v)
        return old_v
      }
    }
    entries.append((k,v))
    keys.append(k)
    return None
  }
  ; Returns the associated value with key k.
  method [](k) {
    pos = _hash(k)
    entries = table[pos]
    if ~entries {
      return None
    }
    for i=0, i<entries.len(), i=i+1 {
      if k == entries[i][0] {
        return entries[i][1]
      }
    }
    return None
  }
  ; Returns True if there is an entry in the Map with the given key k, otherwise False.
  method __in__(k) {
    if self[k] then True else False
  }
  ; Removes the entry in the set with the given key k.
  method remove(k) {
    pos = _hash(k)
    entries = table[pos]
    if ~entries {
      return None
    }
    for i=0, i<entries.len(), i=i+1 {
      if k == entries[i][0] {
        old_v = entries[i][1]
        entries.remove(i)
        keys.remove_value(k)
        return old_v
      }
    }
    return None
  }
  method put_if_absent(k, v) {
    if ~(k in self) {
      self[k] = v
    }
  }
  method compute(k, remapping_fn) {
    old_value = self[k]
    new_value = remapping_fn(k, old_value)
    if new_value {
      self[k] = new_value
    } else if old_value {
      remove(k)
    }
    return new_value
  }
  method compute_if_absent(k, mapping_fn) {
    if ~(k in self) {
      new_value = mapping_fn(k)
      if new_value {
        self[k] = new_value
      }
      return new_value
    }
    return None
  }
  method compute_if_present(k, remapping_fn) {
    old_value = self[k]
    if old_value {
      new_value = remapping_fn(k, old_value)
      if new_value {
        self[k] = new_value
      } else {
        remove(k)
      }
      return new_value
    }
    return None
  }
  method iter() {
    return KVIterator(keys.iter(), self)
  }
  method each(f) {
    for (k, v) in self {
      f(k, v)
    }
  }
  method to_s() {
    kvs = []
    each((k, v) {
      key = if k is String then '\''.extend(k).extend('\'') else str(k)
      kvs.append(cat(key, ': ', v))
    })
    return cat('{', ', '.join(kvs), '}')
  }
}


class Cache {
  field map
  new(sz=31) {
    map = Map(sz)
  }
  method get(k, factory, default=None) {
    v = map[k]
    if v {
      return v
    }
    try {
      v = factory(k)
    } catch e {
      v = default
    }
    map[k] = v
    return v
  }
  method clear(k) {
    map[k] = None
  }
}

class LoadingCache {
  new(field cache=Cache(255), field factory) {}
  method get(k) {
    cache.get(k, factory) 
  }
}

; A collection that contains no duplicate elements.
class Set {
  field map
  new(sz=255) {
    map = Map(sz)
  }
  ; Inserts a given element k into the Set.
  method insert(k) {
    map[k] = k
  }
  ; Removes a given element k from the Set.
  method remove(k) {
    map.remove(k)
  }
  ; Return True if element k is in the Set, otherwise False.
  method __in__(k) {
    k in map
  }
}