import builtin
import error
import io

class Injector {
  field key_map
  new() {
    key_map = {}
  }
  method get(key) {
    constructed_map = {}
    return _get(constructed_map, key)
  }
  method _get(constructed_map, key) {
    if key is Key {
      result = constructed_map[key]
      if result {
        return result
      }
      provider = key_map[key]
      if (provider is Function) or (provider is FunctionRef) {
        result = _provide_function(constructed_map, key, provider)
      } else if provider is Class {
        result = _provide_class(constructed_map, key, provider)
      } else if ~provider {
        result = _provide_class(constructed_map, key)
      } else {
        raise error.Error('Expected provider as a Function or Class but was ' + str(cls))
      }
      constructed_map[key] = result
      return result
    }
    if key is Class {
      return _get(constructed_map, Key(key))
    }
    raise error.Error('Expected key or class but was ' + str(cls))
  }
  method _provide_function(constructed_map, key, provider) {
    provides_annots = None
    if provider is FunctionRef {
      provides_annots = provider.func().annotations.where(a -> a is Provides)
    } else {
      provides_annots = provider.annotations.where(a -> a is Provides)
    }
    if provides_annots.len() > 1 {
      raise error.Error('Expected at most 1 @Provides, but there were ' + str(provides_annots.len()))
    } else if provides_annots.len() == 1 {
      provides_annot = provides_annots[0]
      args = []
      provider_keys = _get_keys(provides_annot.keys)
      for (_, arg_key) in provider_keys {
        args.append(_get(constructed_map, arg_key))
      }
      return provider(_create_args(args))
    }
    return provider()
  }
  method _provide_class(constructed_map, key, provider=None) {
    if ~provider {
      provider = key.cls
    }
    args = _get_args(constructed_map, provider)
    return if args then provider(args) else provider()
  }
  method _get_args(constructed_map, cls) {
    inject_annots = cls.annotations().where(a -> a is Inject)
    if inject_annots.len() > 1 {
      raise error.Error('Expected at most 1 @Inject, but there were ' + str(inject_annots.len()))
    } else if inject_annots.len() == 1 {
      inject_annot = inject_annots[0]
      args = []
      inject_keys = _get_keys(inject_annot.keys)
      for (_, arg_key) in inject_keys {
        args.append(_get(constructed_map, arg_key))
      }
      return _create_args(args)
    }
  }
  method _create_args(args) {
    if ~args or args.len() == 0 {
      return None
    }
    if args.len() == 1 {
      return args[0]
    }
    return tuple(args)
  }
  method install(key, provider=None) {
    if key is ProviderSet {
      _install_provider_set(key)
    } else {
      _install_by_key(key, provider)
    }
    return self
  }

  method _install_by_key(key, provider) {
    if ~provider {
      provider = key
    }
    if ~(key is Key) {
      key = Key(key)
    }
    key_map[key] = provider
  }

  method _install_provider_set(ps) {
    ps.init()
    for (_, meth) in ps.class().methods() {
      provides_annots = meth.annotations.where(a -> a is Provides)
      if provides_annots.len() == 0 {
        continue
      }
      install(provides_annots[0].key, ps.$get(meth.name()))
    }
    for (key, value) in ps._bind_map {
      install(key, value)
    }
    for (_, child_ps) in ps._subsets {
      _install_provider_set(child_ps)
    }
  }

  method _get_keys(keys) {
    if (keys is Array) or (keys is Tuple) {
      return keys
    }
    return [keys]
  }
}

class Key {
  new(field cls, field annot=None) {}
  method ==(other) {
    cls == other.cls and annot == other.annot
  }
  method hash() {
    builtin.hash(cls) + builtin.hash(annot)
  }
  method to_s() {
    cat('Key(cls=', cls, ',annot=', annot, ')')
  }
}

class Inject {
  new(field keys) {}
  method annotate() {}
  method to_s() {
    cat('Inject(keys=', keys, ')')
  }
}

class Provides {
  new(field key, field keys=[]) {}
  method annotate() { _ = None}
  method to_s() {
    cat('Provides(key=', key, ',keys=', keys, ')')
  }
}

class ProviderSet {
  field _bind_map, _subsets
  new() {
    _bind_map = {}
    _subsets = []
  }
  method init() {}
  method bind(from, to=from) {
    _bind_map[from] = to
  }
  method install(ps) {
    _subsets.append(ps)
  }
}
