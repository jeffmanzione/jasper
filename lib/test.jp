import error
import io

class TestClass {
  method annotate(cls) {}
}

class Test {
  method annotate(cls) {}
}

class SetUp {
  method annotate(cls) {}
}

class TearDown {
  method annotate(cls) {}
}

class ExpectError : error.Error {
  new(str) {
    super(error.Error)(str)
  }
}

def expect(actual, expected) {
  try {
    if actual == expected {
      return
    }
  } catch e {}
  raise ExpectError('Expected \'' + str(expected) + '\' but was \'' + str(actual) + '\'.')
}

def expect_raises(exp, error_class=None) {
  try {
    exp()
  } catch e {
    if ~e or ~error_class or (e is error_class) {
      return
    }
    raise ExpectError('Raises wrong error')
  }
  raise ExpectError('Does not raise')
}

self.PASS = color('32;1').extend('PASS').extend(color(0))
self.FAILURE = color('31;1').extend('FAILURE').extend(color(0))

class Tester {
  method test(module) {
    for (_, cls) in module.classes() {
      test_class_annot = _extract_test_class(cls)
      if ~test_class_annot {
        continue
      }
      setups = _extract_methods(cls, SetUp)
      teardowns =  _extract_methods(cls, TearDown)
      for (_, meth) in cls.methods() {
        test_annot = _extract_test(meth)
        if ~test_annot {
          continue
        }
        c = cls()
        method_instance = c.$get(meth.name())
        pass = True
        try {
          setups.each(s -> c.$get(s.name())())
          method_instance()      
          teardowns.each(t -> c.$get(t.name())())
        } catch e {
          ;io.errorln(e)
          pass = False
        }
        io.println(cls.name() + '.' + meth.name() + '=' + (if pass then PASS else FAILURE))
      }
    }
  }

  method _extract_test_class(cls) {
    for (_, annot) in cls.annotations() {
      if annot is TestClass {
        return annot
      }
    }
    return None
  }

  method _extract_test(func) {
    for (_, annot) in func.annotations {
      if annot is Test {
        return annot
      }
    }
    return None
  }

  method _extract_methods(test_cls, cls) {
    methods = []
    for (_, meth) in test_cls.methods() {
      for (_, annot) in meth.annotations {
        if annot is cls {
          methods.append(meth)
        }
      }
    }
    return methods
  }
}
