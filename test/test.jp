import error
import io
import time

class TestClass {
  method annotate(cls) {}
}

class Test {
  method annotate(cls) {}
}

class SetUp {
  method annotate(cls) {}
}

class TearDown {
  method annotate(cls) {}
}

class ExpectError : error.Error {
  new(str) {
    super(error.Error)(str)
  }
}

def expect(actual, expected) {
  try {
    if actual == expected {
      return
    }
  } catch e {}
  raise ExpectError('Not true')
}

self.SUCCESS = color('32;1').extend('SUCCESS').extend(color(0))
self.FAILURE = color('31;1').extend('FAILURE').extend(color(0))

class Tester {
  method test(module) {
    for (_, cls) in module.classes() {
      test_class_annot = _extract_test_class(cls)
      if ~test_class_annot {
        continue
      }
      setups = _extract_methods(cls, SetUp)
      teardowns =  _extract_methods(cls, TearDown)
      for (_, meth) in cls.methods() {
        c = cls()
        test_annot = _extract_test(meth)
        if ~test_annot {
          continue
        }
        method_instance = c.$get(meth.name())
        success = True
        try {
          setups.each(s -> c.$get(s.name())())
        } catch e {
          ;io.errorln(e)
          success = False          
        }
        try {
          method_instance()
        } catch e {
          ;io.errorln(e)
          success = False          
        }
        try {
          teardowns.each(t -> c.$get(t.name())())
        } catch e {
          ;io.errorln(e)
          success = False
        }
        io.println(meth.name() + '=' + (if success then SUCCESS else FAILURE))
      }
    }
  }

  method _extract_test_class(cls) {
    for (_, annot) in cls.annotations() {
      if annot is TestClass {
        return annot
      }
    }
    return None
  }

  method _extract_test(func) {
    for (_, annot) in func.annotations {
      if annot is Test {
        return annot
      }
    }
    return None
  }

  method _extract_methods(test_cls, cls) {
    methods = []
    for (_, meth) in test_cls.methods() {
      for (_, annot) in meth.annotations {
        if annot is cls {
          methods.append(meth)
        }
      }
    }
    return methods
  }
}

@TestClass
class TimeTest {
  @SetUp
  method set_up() {
    io.println('set_up')
  }
  @TearDown
  method tear_down() {
    io.println('tear_down')
  }
  @Test
  method test_Timetamp_to_date() {
    x
  }
  @Test
  method test_Date_to_timestamp() {
    expect(True, False)
  }
}

Tester().test(self)
