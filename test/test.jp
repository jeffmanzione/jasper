import error
import io
import time

class TestClass {
  method annotate(cls) {}
}

class Test {
  method annotate(cls) {}
}

class SetUp {
  method annotate(cls) {}
}

class TearDown {
  method annotate(cls) {}
}

class ExpectError : error.Error {
  new(str) {
    super(error.Error)(str)
  }
}

def expect(actual, expected) {
  try {
    if actual == expected {
      return
    }
  } catch e {
    io.println(e)
  }
  raise ExpectError('Expected \'' + str(expected) + '\' but was \'' + str(actual) + '\'.')
}

def expect_raises(exp, error_class=None) {
  try {
    exp()
  } catch e {
    if ~e or ~error_class or (e is error_class) {
      return
    } else {
      raise ExpectError('Raises wrong error')
    }
  }
  raise ExpectError('Does not raise')
}

self.SUCCESS = color('32;1').extend('SUCCESS').extend(color(0))
self.FAILURE = color('31;1').extend('FAILURE').extend(color(0))

class Tester {
  method test(module) {
    for (_, cls) in module.classes() {
      test_class_annot = _extract_test_class(cls)
      if ~test_class_annot {
        continue
      }
      setups = _extract_methods(cls, SetUp)
      teardowns =  _extract_methods(cls, TearDown)
      for (_, meth) in cls.methods() {
        c = cls()
        test_annot = _extract_test(meth)
        if ~test_annot {
          continue
        }
        method_instance = c.$get(meth.name())
        success = True
        try {
          setups.each(s -> c.$get(s.name())())
        } catch e {
          io.errorln(e)
          success = False          
        }
        try {
          method_instance()
        } catch e {
          io.errorln(e)
          success = False          
        }
        try {
          teardowns.each(t -> c.$get(t.name())())
        } catch e {
          io.errorln(e)
          success = False
        }
        io.println(meth.name() + '=' + (if success then SUCCESS else FAILURE))
      }
    }
  }

  method _extract_test_class(cls) {
    for (_, annot) in cls.annotations() {
      if annot is TestClass {
        return annot
      }
    }
    return None
  }

  method _extract_test(func) {
    for (_, annot) in func.annotations {
      if annot is Test {
        return annot
      }
    }
    return None
  }

  method _extract_methods(test_cls, cls) {
    methods = []
    for (_, meth) in test_cls.methods() {
      for (_, annot) in meth.annotations {
        if annot is cls {
          methods.append(meth)
        }
      }
    }
    return methods
  }
}

@TestClass
class TimeTest {
  @Test
  method test_Timetamp_to_date() {
    ts = time.Timestamp(2023, 5, 28, 13, 45, 22, 666)
    expect(ts.to_date(), time.Date(2023, 5, 28))
  }

  @Test
  method test_Timestamp_to_micros() {
    ts = time.Timestamp(2023, 5, 28, 13, 45, 22, 666)
    expect(ts.to_micros(), 1685306722666000)
  }

  @Test
  method test_Timestamp_equals() {
    ts = time.Timestamp(2023, 5, 28, 13, 45, 22, 666)
    expect(ts == ts, True)
    expect(ts != ts, False)
  }

  @Test
  method test_Timestamp_compare() {
    ts1 = time.Timestamp(2023, 5, 28, 13, 45, 22, 666)
    ts2 = time.Timestamp(2024, 6, 29, 13, 45, 22, 666)
    expect(cmp(ts1, ts2), -1)
  }

  @Test
  method test_Date_to_timestamp() {
    d = time.Date(2023, 5, 28)
    expect(d.to_timestamp(), time.Timestamp(2023, 5, 28))
  }
}

Tester().test(self)
