import async
import error
import inject
import io
import net
import socket
import struct

class Request {}
class Rpc { method annotate(_) {} }

class Get { method annotate(_) {} }
class Head { method annotate(_) {} }
class Post { method annotate(_) {} }
class Put { method annotate(_) {} }
class Delete { method annotate(_) {} }
class Connect { method annotate(_) {} }
class Options { method annotate(_) {} }
class Trace { method annotate(_) {} }
class Patch { method annotate(_) {} }

class RequestController {
  new(field matcher_fn) {}
}

class HttpRequestController : RequestController {
  new(http_matcher_fn) {
    super(RequestController)(http_matcher_fn)
  }
}

class Application {
  field controller_classes

  new(field host, field port) {
    controller_classes = []
  }

  method add_controller(ctrlr_cls) {
    controller_classes.append(ctrlr_cls)
    return self
  }

  method start() {
    io.println('Starting app at ' + str(host) + ':' +  str(port))
    async.create_remote(ApplicationRunner, (host, port, controller_classes))
  }
}

self._REQUEST_METHOD_TO_ANNOTATION = {
  'GET': Get,
  'HEAD': Head,
  'POST': Post,
  'PUT': Put,
  'DELETE': Delete,
  'CONNECT': Connect,
  'OPTIONS': Options,
  'TRACE': Trace,
  'PATCH': Patch
}

@async.RemoteClass
class ApplicationRunner {
  field injector
  new(field host, field port, field controller_classes) {
    injector = inject.Injector()
    for (_, ctrlr_cls) in controller_classes {
      injector.install(ctrlr_cls)
    }
  }

  method process(request) {
    injector.install(Request, () -> request)
    for (_, ctrlr_cls) in controller_classes {
      req_ctrlr = ctrlr_cls.all_annotations().where(a -> a is RequestController)[0]
      if req_ctrlr.matcher_fn(request) {
        ctrlr = injector.get(ctrlr_cls)
        if req_ctrlr is HttpRequestController {
          http_request = net.parse_request(request)
          method_annot = _REQUEST_METHOD_TO_ANNOTATION[http_request.type]
          http_methods = ctrlr_cls.all_methods().where(m -> m.annotations.where(a -> a is method_annot).len() > 0) 
          if http_methods.len() == 0 {
            raise error.Error(str(ctrlr_cls) + ' has no ' + str(method_annot) + ' annotated methods.')
          } else if http_methods.len() > 1 {
            raise error.Error(str(ctrlr_cls) + ' has multiple ' + str(method_annot) + ' annotated methods.')
          }
          return ctrlr.$get(http_methods[0].name())(http_request).to_s()
        } else {
          rpc_methods = ctrlr_cls.all_methods().where(m -> m.annotations.where(a -> a is Rpc).len() > 0)
          if rpc_methods.len() == 0 {
            raise error.Error(str(ctrlr_cls) + ' has no @Rpc annotated methods.')
          } else if rpc_methods.len() > 1 {
            raise error.Error(str(ctrlr_cls) + ' has multiple @Rpc annotated methods.')
          }
          return ctrlr.$get(rpc_methods[0].name())(request)
        }
      }
    }
    raise error.Error('No found controller for request: ' + str(request))
  }

  method run() {
    sock = socket.create_server_socket(host, port)
    while True {
      handle = await sock.accept()
      try {
        await handle.send(process(await handle.receive()))
        handle.close()
      } catch e {
        io.fprintln(io.ERROR, e)
      }
    }
  }
}

class Server {
  field apps

  new() {
    apps = []
  }

  method add_application(app) {
    apps.append(app)
    return self
  }

  method run() {
    await async.all(apps.map(app -> app.start().run()))
  }
}


@HttpRequestController(path -> True)
class IndexController {
  new() {}

  @Get
  method get(http_request) {
    net.HttpResponse().add_content('Hello, world!')
  }
}

@RequestController(path -> True)
class RpcController {
  new() {}

  @Rpc
  method process(request) {
    return True
  }
}

Server()
    .add_application(Application('0.0.0.0', 80).add_controller(IndexController))
    .add_application(Application('0.0.0.0', 1453).add_controller(RpcController))
    .run()